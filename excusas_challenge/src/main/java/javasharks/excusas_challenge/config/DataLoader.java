package javasharks.excusas_challenge.config;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import javasharks.excusas_challenge.model.Fragment;
import javasharks.excusas_challenge.model.FragmentType;
import javasharks.excusas_challenge.model.Ley;
import javasharks.excusas_challenge.model.Meme;
import javasharks.excusas_challenge.model.Rol;
import javasharks.excusas_challenge.repository.FragmentRepository;
import javasharks.excusas_challenge.repository.LeyRepository;
import javasharks.excusas_challenge.repository.MemeRepository;
import javasharks.excusas_challenge.repository.RolRepository;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.boot.CommandLineRunner;
import org.springframework.stereotype.Component;

import java.nio.file.DirectoryStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Iterator;

@Component
public class DataLoader implements CommandLineRunner {

    // Procesa archivos JSON que contienen fragmentos con roles
    private void processFragmentsWithRole(JsonNode root, String fileName) {
        if (!root.isArray()) return;
        for (JsonNode n : root) {
            String texto = findFirstText(n, "texto", "text", "frase", "body", "quote");
            String tipoStr = findFirstText(n, "tipo", "type");
            String role = findFirstText(n, "role", "rol");
            if (texto == null || tipoStr == null || role == null) continue;
            FragmentType tipo;
            try {
                tipo = FragmentType.valueOf(tipoStr.trim().toUpperCase());
            } catch (Exception e) {
                log.warn("Tipo de fragmento desconocido en {}: {}", fileName, tipoStr);
                continue;
            }
            String normalizedRole = normalizeRole(role);
            if (normalizedRole != null) {
                createRoleIfNotExists(normalizedRole);
                Fragment fragment = Fragment.builder().tipo(tipo).texto(texto).role(normalizedRole).build();
                fragmentRepository.save(fragment);
            }
        }
    }

    private static final Logger log = LoggerFactory.getLogger(DataLoader.class);

    private final FragmentRepository fragmentRepository;
    private final MemeRepository memeRepository;
    private final LeyRepository leyRepository;
    private final RolRepository rolRepository;
    private final ObjectMapper mapper = new ObjectMapper();

    public DataLoader(FragmentRepository fragmentRepository, MemeRepository memeRepository, LeyRepository leyRepository, RolRepository rolRepository) {
        this.fragmentRepository = fragmentRepository;
        this.memeRepository = memeRepository;
        this.leyRepository = leyRepository;
        this.rolRepository = rolRepository;
    }

    @Override
    public void run(String... args) throws Exception {
        Path jsonDir = Paths.get("docs", "json");
        if (!Files.exists(jsonDir)) {
            log.warn("Directory docs/json not found, skipping JSON preload");
        } else {
            try (DirectoryStream<Path> stream = Files.newDirectoryStream(jsonDir, "*.json")) {
                for (Path p : stream) {
                    JsonNode root = mapper.readTree(Files.readString(p));
                    // Si el archivo contiene fragmentos con roles, procesar
                    if (root.isArray() && root.size() > 0 && root.get(0).has("role") && (root.get(0).has("tipo") || root.get(0).has("type"))) {
                        processFragmentsWithRole(root, p.getFileName().toString());
                    } else {
                        processFile(p);
                    }
                }
            }
        }

        // Create default roles
        createRoleIfNotExists("dev");
        createRoleIfNotExists("qa");
        createRoleIfNotExists("devops");
        createRoleIfNotExists("pm");

        // create some sample fragments if none exist
        // Ensure we have at least 5 fragments per type (populate from JSON + add auto samples)
        ensureMinimumFragmentsPerTipo(5);
    }

    // Asegura que haya al menos 'min' fragmentos por cada tipo; aÃ±ade textos generados si es necesario
    private void ensureMinimumFragmentsPerTipo(int min) {
        for (FragmentType tipo : FragmentType.values()) {
            var list = fragmentRepository.findByTipo(tipo);
            int current = list == null ? 0 : list.size();
            if (current >= min) continue;
            for (int i = current + 1; i <= min; i++) {
                String texto = String.format("Autogenerated %s sample %d", tipo.name().toLowerCase(), i);
                fragmentRepository.save(Fragment.builder().tipo(tipo).texto(texto).build());
            }
            log.info("Seeded {} fragments for tipo {} (was {})", Math.max(0, min - current), tipo, current);
        }
    }

    private void createRoleIfNotExists(String nombre) {
    // Asigna el resultado para cumplir con el linter
    @SuppressWarnings("unused")
    var unused = rolRepository.findByNombre(nombre).orElseGet(() -> rolRepository.save(Rol.builder().nombre(nombre).build()));
    }

    private void processFile(Path p) {
        try {
            String fileName = p.getFileName().toString().toLowerCase();
            log.info("Processing JSON file: {}", p);
            String content = Files.readString(p);
            JsonNode root = mapper.readTree(content);

            if (fileName.contains("fragment")) {
                // special composite file with contexto/causa/consecuencia/recomendacion
                processCompositeFragments(root);
            } else if (fileName.contains("meme")) {
                // delegate memes processing
                processMemes(root, fileName);
            } else {
                // delegate laws/axioms processing
                processLeyes(root, fileName);
            }

        } catch (Exception e) {
            log.warn("Could not process JSON file {} : {}", p, e.getMessage());
        }
    }

    // Process an array of meme nodes (or single textual nodes)
    private void processMemes(JsonNode root, String fileName) {
        if (!root.isArray()) return;
        for (JsonNode n : root) {
            saveMemeFromNode(n, fileName);
        }
    }

    // Process an array of ley/axiom nodes (or single textual nodes)
    private void processLeyes(JsonNode root, String fileName) {
        if (!root.isArray()) return;
        for (JsonNode n : root) {
            saveLeyFromNode(n, fileName);
        }
    }

    // Process a composite fragments file where each element contains
    // contexto, causa, consecuencia and recomendacion fields
    private void processCompositeFragments(JsonNode root) {
        if (!root.isArray()) return;
        for (JsonNode n : root) {
            String contexto = findFirstText(n, "contexto", "context", "c");
            String causa = findFirstText(n, "causa", "cause");
            String consecuencia = findFirstText(n, "consecuencia", "consequence");
            String recomendacion = findFirstText(n, "recomendacion", "recomendation", "recommendation");
            if (contexto != null) fragmentRepository.save(Fragment.builder().tipo(FragmentType.CONTEXTO).texto(contexto).build());
            if (causa != null) fragmentRepository.save(Fragment.builder().tipo(FragmentType.CAUSA).texto(causa).build());
            if (consecuencia != null) fragmentRepository.save(Fragment.builder().tipo(FragmentType.CONSECUENCIA).texto(consecuencia).build());
            if (recomendacion != null) fragmentRepository.save(Fragment.builder().tipo(FragmentType.RECOMENDACION).texto(recomendacion).build());
        }
    }

    // Persist a Meme built from the JSON node (if valid)
    private void saveMemeFromNode(JsonNode n, String fileName) {
        String nombre = findFirstText(n, "nombre", "name", "title", "titulo");
        String referencia = findFirstText(n, "referencia", "url", "ref");
        String role = findFirstText(n, "role", "rol");
        if (nombre == null && n.isTextual()) {
            nombre = n.asText();
        }
        if (nombre == null) {
            log.warn("Skipping invalid meme node in {}: no nombre/title found", fileName);
            return;
        }

        String finalReferencia = referencia != null ? referencia : fileName;
        // intentar obtener rol desde el nodo; si no existe, inferirlo desde el nombre de archivo
        String normalizedRole = normalizeRole(role);
        if (normalizedRole == null) {
            normalizedRole = inferRoleFromFilename(fileName);
        }

        Meme.MemeBuilder mb = Meme.builder().nombre(nombre).referencia(finalReferencia);
        if (normalizedRole != null) {
            mb.role(normalizedRole);
            createRoleIfNotExists(normalizedRole);
        }

        Meme meme = mb.build();
        log.info("Saving meme from {}: nombre='{}' referencia='{}' role='{}'", fileName, nombre, meme.getReferencia(), normalizedRole);
        memeRepository.save(meme);
    }

    // Persist a Ley built from the JSON node (if valid)
    private void saveLeyFromNode(JsonNode n, String fileName) {
        String texto = findFirstText(n, "texto", "text", "axioma", "frase", "body", "quote");
        String fuente = findFirstText(n, "fuente", "source", "author", "autor");
        String role = findFirstText(n, "role", "rol");
        if (texto == null && n.isTextual()) {
            texto = n.asText();
        }
        if (texto != null) {
            Ley.LeyBuilder lb = Ley.builder().fuente(fuente != null ? fuente : fileName).texto(texto);
            String normalizedRole = normalizeRole(role);
            if (normalizedRole != null) {
                lb.role(normalizedRole);
                createRoleIfNotExists(normalizedRole);
            }
            leyRepository.save(lb.build());
        }
    }

    // Normaliza y valida el rol; devuelve null si el rol no es utilizable
    private String normalizeRole(String role) {
        if (role == null) return null;
        String r = role.trim().toLowerCase();
        return r.isEmpty() ? null : r;
    }

    private String findFirstText(JsonNode node, String... keys) {
        if (node == null) return null;
        if (node.isTextual()) return node.asText();
        for (String k : keys) {
            JsonNode n = node.get(k);
            if (n != null && n.isTextual()) return n.asText();
        }
        // try to iterate object fields for a likely text
        if (node.isObject()) {
            Iterator<String> it = node.fieldNames();
            while (it.hasNext()) {
                String key = it.next();
                JsonNode candidate = node.get(key);
                if (candidate != null && candidate.isTextual()) {
                    return candidate.asText();
                }
            }
        }
        return null;
    }

    // Intenta inferir un rol a partir del nombre de archivo (por ejemplo 'dev-memes.json' -> 'dev')
    private String inferRoleFromFilename(String fileName) {
        if (fileName == null) return null;
        String lower = fileName.toLowerCase();
        // roles conocidos posibles
        String[] candidates = new String[]{"dev", "qa", "devops", "pm", "sre"};
        for (String c : candidates) {
            if (lower.contains(c)) return c;
        }
        // intentar separar por '-' o '_' y tomar primer token
        String base = fileName.replaceAll("\\.json$", "").toLowerCase();
        if (base.contains("-")) return base.split("-")[0];
        if (base.contains("_")) return base.split("_")[0];
        return null;
    }
}
